load("@obazl_rules_ocaml//ocaml:build.bzl",
     "ppx_binary",
     "ppx_library",
     "ppx_module",
     "ppx_ns_module",
     "ppx_archive")

SRCS = [
    "src/token.ml",
    "src/cparser.ml",
    "src/interpreter.ml",
    "src/ppx_optcomp.ml",
]

SUBMODULE_OPTS = ["-verbose"]

## Compile the ns module.

NS = "ppx_optcomp__"

ppx_ns_module(
    name        = "ns_module",
    module_name = "ppx_optcomp__",
    ns          = NS,
    submodules  = SRCS
)

# rename and compile submodules. no preprocessing.
ppx_module( name = "token_cm", impl = "src/token.ml",
            ns   = NS,
            opts = SUBMODULE_OPTS,
            deps = ["@opam//pkg:ppxlib", ":ns_module"])
ppx_module( name = "cparser_cm", impl = "src/cparser.ml",
            ns   = NS,
            opts = SUBMODULE_OPTS,
            deps = ["@opam//pkg:ppxlib", ":ns_module", ":token_cm"])
ppx_module( name = "interpreter_cm", impl = "src/interpreter.ml",
            ns   = NS,
            opts = SUBMODULE_OPTS,
            deps = ["@opam//pkg:ppxlib", ":ns_module"])
ppx_module( name = "ppx_optcomp_cm", impl = "src/ppx_optcomp.ml",
            ns   = NS,
            opts = SUBMODULE_OPTS,
            deps = ["@opam//pkg:ppxlib", ":ns_module", ":cparser_cm", ":interpreter_cm"])

# assemble the parts into an archive
ppx_archive(
    name = "ppx_optcomp",
    msg = "Compiling ppx_optcomp...",
    linkall = True,
    opts = ["-linkall",
            "-verbose"
    ],
    deps = [":ns_module",
            ":token_cm",
            ":cparser_cm",
            ":interpreter_cm",
            ":ppx_optcomp_cm"],
    visibility = ["//visibility:public"]
)

## make a standalone executable
ppx_binary(
    name = "ppx_optcomp.exe",
    opts = ["-linkpkg",
            "-linkall",
            "-verbose",
    ],
    deps = ["@opam//pkg:ppxlib",
            ":ppx_optcomp",
            "@opam//ppxlib:driver_standalone_runner"]
)

################################################################
########    TESTS    ########

#### CAVEAT: support for ppx_inline_test runner is under development.
#### The runner below compiles and runs, but it does not run the
#### tests.

# We have two test modules. Build them as submodules within an ns module namespace.

# Start by constructing the test PPX binary we will use to transform the test sources.

# To use the binary some args must be passed. We pass them to the
# ppx_binary rule, which will propagate them to users of the binary.
PPX_ARGS = ["--cookie", "library-name=\"ppx_optcomp_test\"", "-dump-ast"]

ppx_binary(
    name = "ppx_optcomp_test_ppx",
    # args: will be provided to rules that invoke this binary, just like transitive deps
    args = PPX_ARGS,
    srcs = ["@opam//ppxlib:driver_standalone_shim"],
    opts = ["-w", "-24",
            "-linkpkg",
            "-linkall",
             "-predicates", "ppx_driver",
            "-verbose",
    ],
    # dune: (preprocess (pps ppx_optcomp ppx_inline_test ppx_expect)))
    deps = [
        "@opam//pkg:ppxlib",
        ":ppx_optcomp",
        "@opam//pkg:ppx_inline_test",
        "@opam//pkg:ppx_expect",
        # "@opam//ppxlib:driver_standalone_runner",  # we could do this instead of compiling the shim srcs
    ]
)

# Now generate and compile the ns module. No preprocessing needed,
# since this is generated code.

# The ns will also be passed to ppx_module to build the submodules.
TEST_NS = "ppx_optcomp_test__"

ppx_ns_module(
    name = "test_ns_module",
    module_name = "ppx_optcomp_test__",
    ns  =  TEST_NS,
    submodules = ["test/import_relativity.ml", "test/injection.ml"]
)

# Next, preprocess and compile each test submodule source file.  For
# the preprocessing action we need to pass some args to make
# ppx_inline_test happy; we get them from the ppx target, which we
# parameterized with 'args', above.
ppx_module(
    name = "import_relativity_cm",
    impl = "test/import_relativity.ml",
    opts = ["-verbose", "-linkall",
            "-predicates", "ppx_driver",
    ],
    ns   = TEST_NS,
    # Pass the optional ppx arg to cause preprocessing.
    ppx  = ":ppx_optcomp_test_ppx",
    #FIXME: we do not yet depend on the headers, so changing them will not force a rebuild.
    # data = glob(["test/import_relativity/**/*.mlh"]),
    deps = [
        ":test_ns_module",
        "@opam//pkg:ppx_expect.collector",
    ]
)

ppx_module(
    name = "injection_cm",
    impl = "test/injection.ml",
    ns   = TEST_NS,
    ppx  = ":ppx_optcomp_test_ppx",
    opts = ["-verbose", "-linkall",
            "-predicates", "ppx_driver",
    ],
    args = PPX_ARGS,
    deps = [
        ":test_ns_module",
        "@opam//pkg:ppx_expect.collector",
    ]
)

## Now we build a library and an archive of the test ns module and submodules.

TEST_SUBMODULE_DEPS = [
    ":test_ns_module",
    ":import_relativity_cm",
    ":injection_cm",
    "@opam//pkg:ppx_inline_test",
    "@opam//pkg:ppx_expect",
]

ppx_library(
    name = "ppx_optcomp_test_lib",
    visibility = ["//visibility:public"],
    msg = "Compiling...",
    opts = ["-verbose"],
    deps = TEST_SUBMODULE_DEPS
)

ppx_archive(
    name = "ppx_optcomp_test_archive",
    archive_name = "ppx_optcomp_test",
    visibility = ["//visibility:public"],
    msg = "Compiling ppx_optcomp_test_cmxa...",
    opts = [
        "-linkall",
        "-verbose"
    ],
    deps = TEST_SUBMODULE_DEPS
)


# build the test runner executable, linking against the test archive.
ppx_binary(
    name = "ppx_optcomp_test_runner.exe",
    # srcs = ["@opam//ppx:inline_test_finalizer"],
    opts = ["-w", "-24",
            "-g",
            "-nodynlink",
            "-no-alias-deps",
            # "-c",
            "-linkall",
            "-linkpkg",
            "-predicates", "ppx_driver",
            # "-predicates", "ppx_deriving",
             "-verbose",
    ],
    deps = [
        ## (preprocess (pps ppx_optcomp ppx_inline_test ppx_expect))
        "@opam//pkg:ppxlib",
        # dune secretly injects the following, which
        # injects ppx_inline_test/runner/lib etc.
        # "@opam//pkg:ppx_inline_test",
        # ##NB: in opam, the following package contains let () = Ppx_inline_test_lib.Runtime.exit ()
        # ## but only compiled as a .cmxs, so it does us no good
        # ## let's try this:
        # "@opam//pkg:ppx_inline_test.runtime-lib",
        # "@opam//pkg:ppx_expect",
        # "@opam//pkg:ppx_expect.collector",
        # this is our implementation of the finalizer shim:
        # "@opam//ppxlib:driver_standalone_runner",
        # ":import_relativity_cm",
        # ":injection_cm",
        # ":test_ns_module",
        ":ppx_optcomp_test_archive",
        "@opam//pkg:ppx_inline_test.runner",
    ]
)

# finally run the test. note the '--' to distinguish between bazel args and pgm args.

# bazel/bin/ppx_optcomp_test_runner.exe -- inline-test-runner ppx_optcomp_test -source-tree-root . -verbose -show-counts
